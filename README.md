# Университет Итмо. Кафедра КТ
<h3 id="homework-8">Домашнее задание 8. Markdown to HTML</h3><ol><li>
            Разработайте конвертер из
            <a href="https://ru.wikipedia.org/wiki/Markdown">Markdown</a>-разметки
            в <a href="https://ru.wikipedia.org/wiki/HTML">HTML</a>.
        </li><li>
            Конвертер должен поддерживать следующие возможности:
            <ol><li>
                    Абзацы текста разделяются пустыми строками.
                </li><li>
                    Элементы строчной разметки:
                    выделение (<tt>*</tt> или <tt>_</tt>),
                    сильное выделение (<tt>**</tt> или <tt>__</tt>),
                    зачеркивание (<tt>--</tt>),
                    код (<tt>`</tt>)
                </li><li>
                    Заголовки (<tt>#</tt> * уровень заголовка)
                </li></ol></li><li>
            Конвертер должен называться <tt>Md2Html</tt> и
            принимать два аргумента: название входного файла
            с Markdown-разметкой и название выходного файла
            c HTML-разметкой. Оба файла должны иметь кодировку UTF-8.
        </li><li>
            Пример
          <ul><li>
              Входной файл
            <pre>
# Заголовок первого уровня

## Второго

### Третьего ## уровня

#### Четвертого
# Все еще четвертого

Этот абзац текста,
содержит две строки.

    # Может показаться, что это заголовок.
Но нет, это абзац начинающийся с `#`.

#И это не заголовок.

###### Заголовки могут быть многострочными
(и с пропуском заголовков предыдущих уровней)

Мы все любим *выделять* текст _разными_ способами.
**Сильное выделение**, используется гораздо реже,
но __почему бы и нет__?
Немного --зачеркивания-- еще ни кому не вредило.
Код представляется элементом `code`.

Обратите внимание, как экранируются специальные
HTML-символы, такие как `&lt;`, `&gt;` и `&amp;`.

Знаете ли вы, что в Markdown, одиночные * и _
не означают выделение?
Они так же могут быть заэкранированы
при помощи обратного слэша: \*.



Лишние пустые строки должны игнорироваться.

Любите ли вы *вложеные __выделения__* так,
как __--люблю--__ их я?
            </pre></li><li>
            Выходной файл
            <pre>
&lt;h1&gt;Заголовок первого уровня&lt;/h1&gt;
&lt;h2&gt;Второго&lt;/h2&gt;
&lt;h3&gt;Третьего ## уровня&lt;/h3&gt;
&lt;h4&gt;Четвертого
# Все еще четвертого&lt;/h4&gt;
&lt;p&gt;Этот абзац текста,
содержит две строки.&lt;/p&gt;
&lt;p&gt;    # Может показаться, что это заголовок.
Но нет, это абзац начинающийся с &lt;code&gt;#&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;#И это не заголовок.&lt;/p&gt;
&lt;h6&gt;Заголовки могут быть многострочными
(и с пропуском заголовков предыдущих уровней)&lt;/h6&gt;
&lt;p&gt;Мы все любим &lt;em&gt;выделять&lt;/em&gt; текст &lt;em&gt;разными&lt;/em&gt; способами.
&lt;strong&gt;Сильное выделение&lt;/strong&gt;, используется гораздо реже,
но &lt;strong&gt;почему бы и нет&lt;/strong&gt;?
Немного &lt;s&gt;зачеркивания&lt;/s&gt; еще ни кому не вредило.
Код представляется элементом &lt;code&gt;code&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Обратите внимание, как экранируются специальные
HTML-символы, такие как &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt; и &lt;code&gt;&amp;amp;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Знаете ли вы, что в Markdown, одиночные * и _
не означают выделение?
Они так же могут быть заэкранированы
при помощи обратного слэша: *.&lt;/p&gt;
&lt;p&gt;Лишние пустые строки должны игнорироваться.&lt;/p&gt;
&lt;p&gt;Любите ли вы &lt;em&gt;вложеные &lt;strong&gt;выделения&lt;/strong&gt;&lt;/em&gt; так,
как &lt;strong&gt;&lt;s&gt;люблю&lt;/s&gt;&lt;/strong&gt; их я?&lt;/p&gt;
            </pre></li><li>
            Реальная разметка
<h1 id="N65933">Заголовок первого уровня</h1><h2 id="N65935">Второго</h2><h3 id="N65937">Третьего ## уровня</h3><h4 id="N65939">Четвертого
# Все еще четвертого</h4><p>Этот абзац текста,
содержит две строки.</p><p>    # Может показаться, что это заголовок.
Но нет, это абзац начинающийся с <code>#</code>.</p><p>#И это не заголовок.</p><h6>Заголовки могут быть многострочными
(и с пропуском заголовков предыдущих уровней)</h6><p>Мы все любим <em>выделять</em> текст <em>разными</em> способами.
<strong>Сильное выделение</strong>, используется гораздо реже,
но <strong>почему бы и нет</strong>?
Немного <s>зачеркивания</s> еще ни кому не вредило.
Код представляется элементом <code>code</code>.</p><p>Обратите внимание, как экранируются специальные
HTML-символы, такие как <code>&lt;</code>, <code>&gt;</code> и <code>&amp;</code>.</p><p>Знаете ли вы, что в Markdown, одиночные * и _
не означают выделение?
Они так же могут быть заэкранированы
при помощи обратного слэша: *.</p><p>Лишние пустые строки должны игнорироваться.</p><p>Любите ли вы <em>вложеные <strong>выделения</strong></em> так,
как <strong><s>люблю</s></strong> их я?</p></li></ul></li></ol><h3>Web Crawler</h3><ol><li>
            Напишите Web Crawler, обходящий HTML-страницы
            на заданную глубину и вытаскивающий
            из них картинки.
        </li><li>
            Информация о HTML странице (класс <code>Page</code>:
            <ul><li><code>String url</code> &ndash;
                    URL страницы (идентификатор);
                </li><li><code>String title</code> &ndash;
                    заголовок страницы
                    (содержимое элемента <code>title</code>);
                </li><li><code>List&lt;Page&gt; links</code> &ndash;
                    ссылки (атрибут <code>href</code> элемента <code>a</code>),
                    в порядке появления на странице;
                </li><li><code>List&lt;Page&gt; backLinks</code> &ndash;
                    ссылки, ведущие на страницу;
                </li><li><code>List&lt;Image&gt; images</code> &ndash;
                    Картинки на странице (элемент <code>img</code>),
                    в порядке появления на странице.
                </li></ul></li><li>
            Информация о картинке (класс <code>Image</code>):
            <ul><li><code>String url</code> &ndash;
                    URL картинки (идентификатор);
                </li><li><code>String file</code> &ndash;
                    имя файла, в котором сохранена картинка;
                </li><li><code>List&lt;String&gt; pages</code> &ndash;
                    страницы, на которых встречается картинка.
                </li></ul></li><li>
            Интерфес Web Crawler:
            <pre>
public interface WebCrawler {
    Page crawl(String url, int depth);
}
            </pre></li><li>
            При загрузке на глубину два, должны быть загружены
            и проанализированы  переданная страница и
            страницы, на которые она ссылается.
        </li><li>
            Для загрузки страниц и картинок можно использовать
            метод <a href="https://docs.oracle.com/javase/8/docs/api/java/net/URL.html#openStream--">openStream</a>
            класса <a href="https://docs.oracle.com/javase/8/docs/api/java/net/URL.html">URL</a>.
        </li><li>
            Вы можете считать, что все страницы имеют кодировку UTF-8.
        </li></ol><h3>Offline Browser</h3><ol><li>
            Напишите Offline Browser, обходящий HTML-страницы
            на заданную глубину и сохраняющий их для
            offline-просмотра.
        </li><li>
            Вместе с HTML-страницами должны быть загружены
            сопутствующие ресурсы:  картинки, скрипты и css-файлы.
            При сохранении не должны создаваться лишние
            копии ресурсов.
        </li><li>
            Ссылки на сохраненные страницы должны быть  изменены так,
            чтобы работать без подключения к Интернету.
            Ссылки на другие страницы должны остаться без изменений.
        </li><li>
            Вы можете считать, что все страницы имеют кодировку UTF-8.
        </li><li><em>Примечание</em>.
            В результате работы наивного offline-браузера, некоторые
            страницы (например, использующие динамическую загрузку
            скриптов и CSS) могут отображаться некорректно.
            Правильная загрузка таких сайтов не входит в
            данное домашнее задание.
        </li></ol><h3>Очереди</h3><ol><li>
            Определите интерфейс очереди <code>Queue</code> и опишите его контракт.
        </li><li>
            Реализуйте класс <code>LinkedQueue</code> &mdash; очередь на связном списке.
        </li><li>
            Выделите общие части классов <code>LinkedQueue</code>
            и <code>ArrayQueue</code> в базовый класс <code>AbstractQueue</code>.
        </li></ol>
